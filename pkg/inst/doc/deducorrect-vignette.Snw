%\VignetteIndexEntry{deducorrect}
\documentclass[11pt, fleqn, a4paper]{article}
\usepackage[english]{babel}
\usepackage{amsmath, amssymb}
\usepackage{natbib}
\usepackage{algpseudocode}
\usepackage{algorithm}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{threeparttable}

% stimulate latex to put multiple floats on a page.
\setcounter{topnumber}{2}
\setcounter{bottomnumber}{2}
\setcounter{totalnumber}{3}
\setcounter{dbltopnumber}{2}
\renewcommand{\topfraction}{.9}
\renewcommand{\textfraction}{.1}
\renewcommand{\bottomfraction}{.75}
\renewcommand{\floatpagefraction}{.9}
\renewcommand{\dblfloatpagefraction}{.9}
\renewcommand{\dbltopfraction}{.9}


\title{Correction of rounding, typing, and sign errors with the {\tt deducorrect} package}
\author{Mark van der Loo, Edwin de Jonge and Sander Scholtus}
\begin{document}
\maketitle
\begin{abstract}
{\em This vignette is unfinished. Version 1.0 of the package will contain a
full vignette.} 

Since raw (survey) data usually has to be edited before statistical analysis
can take place, the availability of data cleaning algorithms is important to
many statisticians.  In this paper the implementation of three data correction
methods in R. The methods of this package can be used to correct numerical data
under linear restrictions for typing errors, rounding errors, sign errors and
value interchanges. The algorithms, based on earlier work of Scholtus, are
described as well as implementation details and coded examples. Although the
algorithms have originally been developed with financial balance accounts in
mind the algorithms are formulated genericly and should find a wider range of
application.


\end{abstract}

<<echo=FALSE,results=hide, keep.source=FALSE>>=
library(deducorrect)
@
\maketitle

\newpage

\tableofcontents
\listofalgorithms
\newpage
\section{Introduction}
Raw statistical data  is often plagued with internal inconsistencies and errors
which inhibit reliable statistical analysis. Establishment survey data is
particularly prone to in-record inconsistencies, because the numerical
variables contained in these data are usually interrelated by many mathematical
relationships. Before statistical analysis can take place, these relationships
have to be checked and violations should be resolved as much as possible.
While establishing that a record violates certain relationships is
straightforward, deciding which fields in a record contain the actual errors
can be a daunting task. In the past, much attention has been paid to this
decision problem, often using Fellegi and Holt's principle \citep{fellegi:1976}
as the point of departure. This principle states that for non-systematic errors, and
with no information on the cause of errors, one should try to make a record
consistent by changing as few variables as possible.

This principle precludes using the data available in the (possibly erroneous)
fields to detect and correct the error. In certain cases, naively applying
Fellegi and Holt's principle will yield consistent records with nevertheless
faulty data. As an example, consider a survey record with three variables $x$,
$y$ and $z$, which have to obey the relationship $x=y-z$. Such relationships
frequently occur in financial profit-loss accounts. If a record happens to have
values such that $x=z-y$, then Fellegi and Holt's principle suggests that
either the numerical value of $x$, $y$ or $z$ should be adapted in such a way
that the relationship holds, while the values in the record suggest that the
values in fields $y$ and $z$ might have been interchanged. Swapping the values
of $z$ and $y$ therefore seems a reasonable solution although it formally means
changing two values.

\subsection{Deductive correction}
We use the term deductive correction to indicate methods wich use information
available in inconsistent records to deduce and solve the probable cause of
error. Recently, a number of algorithms for deductive correction have
been proposed by \cite{scholtus:2008, scholtus:2009}. These algorithms
can solve problems not uncommon in numerical survey data, namely
%
\begin{itemize}
\item Rounding errors.
\item Simple typing errors.
\item Sign swaps and/or value interchanges.
\end{itemize}
%
The algorithms focus on solving problems in records with linear relationships,
which can be written in any (combination of) the forms
%
\begin{eqnarray}
\label{edits1}
Ax &=& b\\
\label{edits2}
Ax &<& b \\
\label{edits3}
Ax &\leq& b \\
\label{edits4}
Ax &>& b \\
\label{edits5}
Ax &\geq& b 
\label{edits6}
\end{eqnarray}
%
Here, every $A$ is a matrix, $x$ a numerical data record and $b$ a constant
vector. Every row of the combined matrix $[A,b]$ represents one linear
restriction. In data-editing literature the restrictions imposed on records are
often called edit rules, or edits in short. If an edit describes a relationship
between a number of variables $\{x_j\}$, we say that the edit {\em contains}
the variables $\{x_j\}$. Conversely, when $x_j$ is part of a relationship
defined by an edit we say that $x_j$ {\em occurs} in the edit. 

In this paper, we describe the {\tt deducorrect} package for R
\citep{R-core:2011}, which implements (slight) generalisations of the
algorithms proposed by \cite{scholtus:2008, scholtus:2009}. The purpose of this
paper is to provide details on the algorithms and to familiarize users with the
syntax of the package. The correction algorithms in the package report the
results in a uniform matter. Section \ref{deducorrectObjectSection} provides
details on the {\tt deducorrect} output object which stores information on
corrected records, applied corrections, and more. Sections
\ref{roundingErrors}, \ref{typingErrors} and \ref{signErrors}, provide details
on the classes of problems that may be treated with the package, an exposition
of the algorithms used and coded examples with analysis of the results. It is
also shown how the examples from \cite{scholtus:2008} and \cite{scholtus:2009}
can be treated with this software. The package requires that linear
relationships are defined with the {\tt editrules} package \citep{jonge:2011}.
Unless noted otherwise, all R-code examples in this paper can be executed from
the R commandline after loading the {\tt deducorrect} and {\tt editrules}
package. 


\subsection{The {\tt deducorrect} object and {\tt status} values}
\label{deducorrectObjectSection}
Apart from the corrected records, every {\tt correct-} function of the {\tt
deducorrect} package returns some logging information on the applied
corrections. Information on applied corrections, a status indicator per record,
a timestamp and user information are included and stored uniformily in a
{\tt deducorrect} object. See Table \ref{deducorrectObject} for an
overview of the contents of a {\tt deducorrect} object.
%
\begin{table}
\begin{threeparttable}
\caption{Contents of the {\tt deducorrect} object. All slots can be accessed or reassigned through the {\tt \$} operator.}
\label{deducorrectObject}
\begin{tabular}{lp{0.7\textwidth}}
\hline
{\tt corrected}   & The input data with records corrected where possible.\\
{\tt corrections} & A {\tt data.frame} describing the corrections. Every record contains a row number, labeling the
row in the input data, a variable name of the input data, the old value and the new value.\\
{\tt status} & A {\tt data.frame} with at least one column giving treatment information of every record in the input data.
    Depending on the {\tt correct} function, some extra columns may be added. \\
{\tt timestamp}   & The date and time when the {\tt deducorrect} object was created.\\
{\tt generatedby} & The name of the function that called {\tt newdeducorrect} to create the object.\\
{\tt user}        & The name of the user running R, deduced from the environment variables of the system using R.\\
\hline
\end{tabular}
\end{threeparttable}
\end{table}
%
Because of the large amount of information in a {\tt deducorrect} object, the
contents are summarized for printing to screen. In the example below, we define
one record of data, a linear restriction in the form of an {\tt editmatrix},
and apply the {\tt correctSigns} correction method\footnote{sometimes extra
brackets are included to force R to print the result}.
<<>>=
(d <- data.frame(x=1,y=0,z=1))
require(editrules)
E <- editmatrix("x==y-z")
sol <- correctSigns(E,d)
sol
@
%

\begin{table}
\begin{threeparttable}
\caption{The number of equalities $n$ and inequalities $m$ violated by an edit,
before and after treatment with one of the correct-functions of {\tt
deducorrect}. The label {\rm N/A} indicates that this exit status does not
occur in the function.}
\label{statusvalues}
\begin{tabular}{cccclll}
\hline
\multicolumn{2}{c}{Before}&\multicolumn{2}{c}{After}&\multicolumn{3}{c}{status}\\
Eqs&  Ineqs &  Eqs  &Ineqs   &{\tt correctSigns}   & {\tt correctRounding} &{\tt correctTypos}\\
\hline
$0$  &  $0$     &  $0$    &$0$      &valid          & valid           &valid\\
$0$  &  $m$     &  $0$    &$m$      &invalid        & invalid         &invalid\\
$n$  &  $0$     &  $n$    &$0$      &invalid        & invalid         &invalid\\
$n$  &  $0$     &  $<n$   &$0$      &N/A              & partial         &partial\\
$n$  &  $0$     &  $0$    &$0$      &corrected      & corrected       &corrected\\
$n$  &  $m$     &  $n$    &$m$      &invalid        & invalid         &invalid\\
$n$  &  $m$     &  $<n$   &$0$      &N/A               & partial         &partial\\
$n$  &  $m$     &  $<n$   &$<m$     &N/A               & partial         &partial\\
$n$  &  $m$     &  $0$    &$0$      &corrected      &corrected        &corrected\\
\hline
\end{tabular}
\end{threeparttable}
\end{table}

The individual components of {\tt sol} can be retrieved with the
dollar-operator. The slot {\tt corrected} is the same as the input data, but
with corrected records, where possible:
<<>>=
sol$corrected
@
The applied corrections are stored in the {\tt corrections} slot.
<<>>=
sol$corrections
@
Every row in {\tt corrections} tells wich variable in which row of the input
data was changed, and what the old and new values are. The {\tt status} slot
gives details on the status of the record.
<<>>=
sol$status
@
The first column is an indicator which can take five different values,
indicating whether validity could be established, and/or if the record could be
(partially) corrected by the method which created the deducorrect object. See
Table \ref{statusvalues} for details. The rest of the columns depend on the
function which created the object and can provide more details on the chosen
solutions. These are described in the following sections.


\subsection{Balance accounts and totally unimodular matrices}
\label{totallyUnimodularSection}
Most algorithms described here have been designed with financial balance
accounts in mind. The balance accounts encountered in establishment surveys
mostly involve integer records since financial amounts are usually reported in
currency (kilo-)units. Therefore, linear editrules of the form
%
\begin{equation}
\label{integerRestrictions}
Ax = b \textrm{ with } A\in \{-1,0,1\}^{m\times n}\textrm{, } x\in \mathbb{Z}^{n},\textrm{ and } b\in\mathbb{Z}^m.
\end{equation}
are frequently encountered. In all the examples of financial balance accounts
encountered by the authors, the matrix $A$ happened to be totally unimodular.
A (not necessarily square) matrix is called {\em totally unimodular} when every
square submatrix has determinant ${-1}$, $0$, or $1$. The scapegoat algorithm
\citep{scholtus:2008}, which is used in the {\tt correctRounding} function,
requires $A$ to be totally unimodular. See appendix B of \cite{scholtus:2008}
for a further discussion of total unimodularity.  The {\tt deducorrect} package
offers the function {\tt isTotallyUnimodular} which checks if a matrix is
totally unimodular. The algorithm follows  a recursive procedure given below.
\begin{algorithmic}[1]
\Procedure{isTotallyUnimodular}{$A$}
\State $A\leftarrow${\sc reduceMatrix}$(A)$
\If {$A=\varnothing$}
\State\Return {\sc TRUE}
\ElsIf {Each column of $A$ has exactly 2 nonzero elements}
\State\Return {\sc hellerTompkins}$(A)$
\Else
\State $\mathcal{B} \leftarrow${\sc raghavachari}$(A)$
\If { Every $B\in\mathcal{B}$ {\sc isTotallyUnimodoular}($B$) }
\State \Return {\sc TRUE}
\Else
\State \Return{\sc FALSE}
\EndIf
\EndIf
\EndProcedure
\end{algorithmic}
Here, {\sc reduceMatrix} iteratively removes all rows and columns of $A$ which
have a single nonzero element (an operation of $\mathcal{O}(n)$ in the number
of columns and rows).  When possible, the criterium of \cite{heller:1956},
which is $\mathcal{O}(2^n)$ in the number of columns is used to determine
unimodularity.  If this is not possible, a series of smaller matrices
$\mathcal{B}$ is derived with the method of \cite{raghavachari:1976}. Every
matrix in $\mathcal{B}$ is subsequently checked for total unimodularity by
calling {\sc isTotallyUnimodular}. In the worst case, Rachavachari's method
must be called recursively and checking for unimodularity is $\mathcal{O}(n!)$
in the number of columns. In practical applications $A$ is often fairly sparse
and only a small portion of $A$ has to be treated with the Rachavachari method.



\section{\tt correctRounding}
\label{roundingErrors}
\subsection{Area of application}
This function can be used to correct records which violate linear equality
restrictions because of rounding errors in one or more variables. The linear
equality restrictions must be of the form
\begin{displaymath}
Ax = b \textrm{ with } A\in \{-1,0,1\}^{m\times n}\textrm{, } x\in \mathbb{Z}^{n},\textrm{ and } b\in\mathbb{Z}^m.
\end{displaymath}
where $A$ is a totally unimodular matrix (see Section
\ref{totallyUnimodularSection}), which can be tested with the function {\tt
isTotallyUnimodular}.

\subsection{How it works}
The {\tt correctRounding} function uses the scapegoat algorithm described in
\cite{scholtus:2008} to suggest corrections for linear equality violations.
Linear inequalities are ignored, except that corrections which cause new
inequality violations are not accepted. The algorithms selects editrules
violated by rounding errors. Rounding errors cause small deviations from
equality and therefore deviations smaller than some $\varepsilon$ (say,
$\varepsilon=2)$ are assumed to stem from rounding errors. Next, a number of
variables --called scapegoat variables-- is selected randomly in such a way
that rounding errors can be solved exactly and uniquely. If the chosen solution
happens to cause new inequality violations, the solution is rejected and a new
set of scapegoat variables is drawn. This is repeated at most $k$ times.  See
Algorithm \ref{scapegoatAlgorithm} for a consice description of the basic
procedure (without checking for inequalities).

%
%
\begin{algorithm}[t]
\caption{Scapegoat algorithm}
\label{scapegoatAlgorithm}
\begin{algorithmic}[1]
\Require Equality restriction matrix $A$ and constant vector $b$, record $x$,
    rounding tolerance $\varepsilon$. 
\State Remove rows from the system  $Ax=b$ not satisfying $|A_{i\cdot}x-b_i|<\varepsilon$. 
\If{$A\not=\varnothing$ {\bf and} $||Ax-b||>0$}
\State Randomly permute columns of $A$. Permute $x$ and $b$ accordingly.
\State Use QR decomposition to partition $A$ columnwise in a square invertible
    matrix $A_1$ and remaining columns $A_2$.  Partition $x$ in $x_1$ and $x_2$,
    and $b$ in $b_1$ and $b_2$ accordingly.
\State $x_1\leftarrow A_1^{-1}(b-A_2x_2)$
\State Unpermute $[x_1,x_2]$
\EndIf
\State Restore $x$ by adding the previously removed elements.
\Ensure $x$
\end{algorithmic}
\end{algorithm}
%
%

%
%
\subsection{Examples}
Here, we will reproduce the example of \cite{scholtus:2009}, Section 5.3.2.
Consider an integer-valued record with 11 variables, subject to the rules:
<<keep.source=true>>=
E <- editmatrix( c("X1 + X2 == X3"
                  ,"X2 == X4"
                  ,"X5 + X6 + X7 == X8"
                  ,"X3 + X8 == X9"
                  ,"X9 - X10 == X11"))
@
Consider also the following inconsistent record:
<<>>=
(dat <- data.frame(t(c(12, 4, 15, 4, 3, 1, 8, 11, 27, 41, -13))))
violatedEdits(E,dat)
@
As reported by the {\tt violatedEdits} function, this record violates editrules
1, 3, 4, and 5.  Using R's built-in matrix operations, we may check which edits
might be violated because of rounding errors:
<<>>=
E %*% t(as.matrix(dat))
@
which, in this case is the same since all violations fall within the limit we
expect rounding errors.  Repairing the record can be done with
<<>>=
set.seed(1)
sol <- correctRounding(E,dat)
cbind(sol$corrected, sol$status)
sol$corrections
@
Here, we used {\tt set.seed} to make results reproducible. The result is not
exactly the same as the solution found in the reference. Here, variables $x_3$,
$x_8$ and $x_9$ have been adapted, while in the reference $x_3$, $x_8$ and
$x_9$ were adapted.  Since corrections are very small, smearing out the
effect of adaptations over a number of variables is a reasonable option.

%
%
%
\section{\tt correctTypos}
\label{typingErrors}
%
\subsection{Area of application}
This function can be used to correct typographical errors in an integer record
violating linear equality constraints as in Eq.\ \eqref{integerRestrictions}:
\begin{displaymath}
Ax = b \textrm{ with } A\in \{-1,0,1\}^{m\times n}\textrm{, } x\in \mathbb{Z}^{n},\textrm{ and } b\in\mathbb{Z}^m.
\end{displaymath}
The algorithm was developed with sets of financial balance equations in mind,
where these type of problems are very common. As far as inequalities are
concerned, they are currently ignored by the algorithm, in the sense that no
attempt is made to repair inequality violations. However, the algorithm does
not allow solutions causing extra inequality violations.

Records which violate the equality restrictions are treated. There is an option
{\tt eps} which allows for a tolerance in checking if records should be
treated. This way, records containing ony rounding errors can be ignored but do
note that they will retrieve the status {\tt valid}.
 

\subsection{How it works}
In short, the algorithm first computes a list of suggestions which correct one
or more violated edits (Algorithm \ref{generateCandidates}). The corrections
not corresponding to a typographical error are removed, after which  the set of
suggestions that maximize the number of satisfied editrules is determined
(Algorithm \ref{maximizeResolvedEdits}). 

Suggestions are generated for the set of variables which {\em only} occur in
violated edits since altering these variables will have no effect on already
satisfied edits. For every variable $x_j$, define the matrix $A^{(j)}$ who's
rows represent edits containing $x_j$. Suggestions $\tilde{x}^{(i)}_j$ for
every row $i$ of $A^{(j)}$ can be generated by solving for $x_j$:
%
\begin{equation}
\tilde{x}_j^{(i)} = \frac{1}{A_{ij}^{(j)}} \left(b_i - \sum_{j'\not=j}A_{ij'}^{(j)}x_j\right).
\end{equation}
%
We keep only the unique suggestions, and reject solutions which are more than a
certain Damerau-Levenshtein distance removed from the original value. The {\em
Damerau-Levenshtein} distance $d_{\rm DL}$ between two strings $s$ and $t$ is
the minimum number of character insertions, deletions, substitutions and
transpositions necessary to change $s$ into $t$ or {\em vice versa}
\citep{damerau:1964,levenshtein:1966}.  The remaining set of suggestions
$\{x^{(i)}_j\}$ will in general contain multiple suggestions for each violated
edit $i$ and multiple suggestions for each variable $x_j$. Using a tree search
algorithm, a subset of $\{x^{(i)}_j\}$ is selected which maximizes the number
of resolved edits. The tree search is sped up considerably by pruning branches
which resolve the same edit multiple times or use multiple suggestions for the
same variable.

This algorithm generalizes the algorithms of \cite{scholtus:2009} in the
following two ways: first, the imposed linear restrictions are generalised from
$Ax=0$ to $Ax=b$. Secondly, the original algorithm allowed for a single {\em
digit} insertion, deletion, transposition or substitution. The more general
Damerau-Levenshtein distance used here treats the digits as characters,
allowing for sign changing, which is forbidden if only digit changes are
allowed. Also, by applying a standard Damerau-Levenshtein algorithm it is easy
to allow for corrections spanning larger values $d_{\rm DL}$. That is, one
could allow for multiple typos in a single field. Moreover, the
Damerau-Levenstein distance as implemented in the {\tt deducorrect} package
allows one to define different weights to the four types of operations
involved, adding some extra flexibility to the method.
%
%
\begin{algorithm}[t]
\caption{Generate solution candidates}
\label{generateCandidates}
\begin{algorithmic}[1]
\Require Record $x$, a set of linear equality restrictions and a list of variables to {\tt fixate}. A maximum
Damerau-Levenshtein distance {\tt maxdist}.
\State $L\leftarrow\varnothing$
\State Determine $J_0=\{j: x_j \textrm{ occurs {\em only} in violated edits and not in {\tt fixate}}\}$
\For { $j\in J_0$}
\State Determine the matrix $A^{(j)}$ of violated edits containing $x_j$ and associated constant vector $b^{(j)}$
\For { every row $i$ of $A^{(j)}$}
\State $\tilde{x}_j^{(i)} \leftarrow \left(b_i^{(j)}-\sum_{j'\not=j}A_{ij'}^{(j)}x_{j'}\right)/A_{ij}^{(j)} $
\State $L\leftarrow L\cup\tilde{x}_j^{(i)}$
\EndFor
\EndFor
\State Remove $\tilde{x}^{(i)}_j$ from $L$ for which $d_{\rm DL}(\tilde{x}^{(i)}_j,x_j)>{\tt maxdist}$ 
\Ensure List $L$ of $m$ unique solution suggestions for record $x$.
\end{algorithmic}
\end{algorithm}
%
\begin{algorithm}[t]
\caption{Maximize number of resolved edits}
\label{maximizeResolvedEdits}
\begin{algorithmic}[1]
\Require Record $x$, a list of linear equality restrictions and a list of solution suggestions
$L = \{L_\ell=\tilde{x}^{(i_\ell)}_{j_\ell}:\ell=1,2,\ldots, m\}$
\State $k\leftarrow 0$ 
\State $s\leftarrow {\sf NULL}$
\Procedure{tree}{$x,L$}
\If{$L\not=\varnothing$}
\State {\sc tree}$(x,L\backslash L_1)$\Comment{Left branche: don't use suggestion}
\State $x_{j_1}\leftarrow L_1$ \Comment{Right branche: use suggestion}
\State $L\leftarrow L\backslash \{x^{(i_\ell)}_{j_\ell}\in L: j_\ell=j_1 \textrm{ \bf  or } x^{(i_\ell)}_{j_\ell}\textrm{ resolves the same edit as } L_1\}$
\State {\sc tree}$(x,L)$
\Else
\If{Number of edits $n$ resolved by $x$ larger then $k$}
\State $k \leftarrow n$
\State $s \leftarrow x$
\EndIf
\EndIf
\EndProcedure
\Ensure { (partial) solution $s$, resolving maximum number of edits. }
\end{algorithmic}
\end{algorithm}

\subsection{Examples}
In this section we show the most important options of the {\tt correctTypos}
function.  After a simple, worked-out example we reproduce the results in
Chapter 4 of \cite{scholtus:2009}.

First, define a simple one-record dataset with an associated edit rule.
<<>>=
dat <- data.frame(x = 123, y = 192, z = 252)
(E <- editmatrix("z == x + y"))
@
Obviously, the edit in {\tt E} is not satisfied since $123+192=315$. As can be
seen from the output of {\tt editmatrix}, we have $b=0$, so the correction
candidates here are:
\begin{eqnarray}
\tilde{x}^{(1)} &=& 0 - \frac{-1\cdot 192+1\cdot252}{-1} = 60\\
\tilde{y}^{(1)} &=& 0 - \frac{-1\cdot 123+1\cdot252}{-1} = 129\\
\tilde{z}^{(1)} &=& 0 - \frac{-1\cdot 123-1\cdot192}{1} = 315 
\end{eqnarray}
The Damerau-Levenshtein distances between the candidates and their originals
are given by:
\begin{eqnarray}
d_{\rm DL}(\tilde{x}^{(1)},x) &=& 3\textrm{ (two substitutions and an insertion)}\\
d_{\rm DL}(\tilde{y}^{(1)},y) &=& 1\textrm{ (one transposition)}\\
d_{\rm DL}(\tilde{z}^{(1)},z) &=& 3\textrm{ (three substitutions)}
\end{eqnarray}
In this case, there is just one candidate with $d_{\rm DL}=1$, solving the 
inconsistency with just one digit transposition. Running the record through 
{\tt correctTypos} indeed finds the digit transposition:
<<>>=
correctTypos(E, dat)$corrected
@
%
\cite{scholtus:2009} (Chapter 4) treats a series of examples which we will
reproduce here.  We consider a dataset with 11 variables, subject to the
following edit rules.
<<keep.source=true>>=
E <- editmatrix( c("x1 + x2 == x3"
                  ,"x2 == x4"
                  ,"x5 + x6 + x7 == x8"
                  ,"x3 + x8 == x9"
                  ,"x9 - x10 == x11"))
@
%
The following dataframe contains the correct record ({\tt example 4.0}) as well
as the manipulated erroneous records.
<<keep.source=true,echo=false>>==
dat <-as.data.frame( matrix(c(
    1452, 116, 1568, 116, 323, 76, 12, 411,  1979, 1842, 137,
    1452, 116, 1568, 161, 323, 76, 12, 411,  1979, 1842, 137,
    1452, 116, 1568, 161, 323, 76, 12, 411, 19979, 1842, 137,
    1452, 116, 1568, 161,   0,  0,  0, 411, 19979, 1842, 137,
    1452, 116, 1568, 161, 323, 76, 12,   0, 19979, 1842, 137), 
    byrow=TRUE,nrow=5))
rownames(dat) <- paste("example 4.",0:4,sep="")
colnames(dat) <- paste("x",1:11,sep="")
@
<<>>=
dat
@
This {\tt data.frame} can be read into R by copying the code from the {\tt
correctTypos} help page. As can be seen, example 4.1 has a single digit
transposition in $x_4$, example 4.2 has the same error, and an extra 1 prefixed
to $x_9$, example 4.3 contains multiple extra errors (in $x_5$, $x_6$ and $x_7$
which cannot be explained bby simple typing errors.  Finally, example 4.4 also
has multiple errors which cannot all be explained by simple typing errors. This
example has multiple solutions which solve an equal amount of errors.

The violated edit rules may be listed with the function
<<>>=
violatedEdits(E,dat)
@
Now, to apply as many typo-corrections as possible:
<<>>=
sol <- correctTypos(E, dat)
cbind(sol$corrected, sol$status)
@
Our implementation finds the exact same solutions as in the original paper of
\cite{scholtus:2009}.  Also see this reference for a through analysis of the
outcomes.

%
%
%
\section{\tt correctSigns}
\label{signErrors}
\subsection{Area of application}
This function can be used to solve sign errors and value swaps which cause
linear equalities (Eq. \ref{edits1}) to fail. Possible presence of linear
inequalities [Eq. \eqref{edits2}-\eqref{edits6}] are taken into account
when resolving errors, but they are not part of the error detection process.


\subsection{How it works}
The function {\tt correctSigns} tries to change the sign of (combinations of)
variables and/or swap the order of variables to repair inconsistent records.
Sign flips and value swaps are closely related since
\begin{equation}
-(x - y) = y - x,
\end{equation}
These simple linear relations frequently occur in profit-loss accounts for
example.  Basically, {\tt correctSigns} first tries to correct a record by
changing one sign. If that doesn't yield any solution, it tries changing two,
and so on. If the user allows value swaps as well, it starts by trying to
correct the record with a single sign flip or variable swap. If no solution is
found, a combination is tried, and so on. The algorithm only treats the
variables which have nonzero coefficients in one of the violated rows of Eq.\
\eqref{edits1}.  Since the number of combinations grows exponentially with the
number of variables to treat, the user is given some control over the volume of
the search space to cover in a number of ways. First of all, the variables
which are allowed to flip signs or variable pairs which may be interchanged
simultaneously can be determined by the user. Knowledge of the origin of the
data will usually give a good idea on which variables are prone to sign errors.
For example, in surveys on profit-loss accounts, respondents sometimes
erroneously submit the cost as a negative number. Secondly, the user may limit
the maximum number of simultaneous sign flips and or value swaps that may be
tested. This is controled by the {\tt maxActions} parameter in Algorithm
\ref{correctSigns}.  The third option limiting the search space is to break
when the number of combinations, given a number of actions to try becomes too
large. This is controlled by the {\tt maxCombinations} parameter in Algorithm
\ref{correctSigns}.
%
%
\begin{algorithm}[t]
\caption{Record correction for {\tt correctSigns}}
\label{correctSigns}
\begin{algorithmic}[1]
\Require A numeric record $x$, a tolerance $\varepsilon$. A set of equality and
    inequality constraints of the form
\begin{eqnarray*}
Ax - b &=& 0\\
Bx - c &\geq& 0,
\end{eqnarray*}
A list {\tt flip} of variables whos signs may be fliped, a list {\tt swap} of
variable pairs whos values may be interchanged, an integer {\tt maxActions}, an
integer {\tt maxCombinations} and a weight vector.

\State Create a list {\tt actions}, of length $n$ containing those elements of {\tt flip} and {\tt swap} that
    affect variables that occur in violated rows of $A$.
\State Create an empty list $S$.
\State $k\leftarrow 0$
\While {$S=\varnothing$ {\bf and} $k<\min({\tt maxActions},n)$}
  \If {{\bf not} ${n\choose k}>{\tt maxCombinations}$}
   \State $k\leftarrow k+1$ 
   \State Generate all ${n\choose k}$ combinations of $k$ actions.
   \State Loop over those combinations, applying them to $x$. Add solutions
obeying $|Ax-b|<\varepsilon$ and $Ax-c\geq0$ to $S$.
  \EndIf
\EndWhile
\If {{\bf not} $S=\varnothing$ }
\State Compute solution weights and choose solution with minimum weight. Choose
the first solution in the case of degeneracy.
\EndIf
\end{algorithmic}
\end{algorithm}

To account for sign errors and variable swap errors which are masked by
rounding errors, the user can provide a nonegative tolerance $\varepsilon$, so
the set of equality constraints are checked as
\begin{equation}
|Ax -b| < \varepsilon,
\end{equation}
where $|\cdot|$ indicates the elementwise absolute value. The default value of
$\varepsilon$ is the square root of machine accuracy which amounts to
approximately $10^{-8}$ on a 32-bit architecture. 

The purpose of this algorithm is to find and apply the minimal number of
actions (sign flips and/or variable swaps) necessary to repair the record. It
is not guaranteed that a solution exists, nor that the solution is unique. If
multiple solutions are found, the solution which minimizes a weight is chosen.
The user has the option to assign weights to every variable, or to every
action.  The total weight of a solution is the sum over the weights of the
altered variables or the sum over the weight of the actions performed. Actions
with heigher weight are therefore less likely to be performed and variables
with higher weight are less likely to be altered.

This algorithm is a generalization of the original algorithms in
\cite{scholtus:2008} in two ways. First, the original algorithm was designed
with a specific type of profit-loss account in mind, while the algorithm of
{\tt deducorrect} can handle any set of linear equalities. Second, the original
algorithm was not designed to take account of inequality restrictions, which is
a feature of the algorithm in this work. In Section
\ref{exScholtusCorrectSigns} it is shown how the results of the original
example can be reproduced.



%
%
\subsection{Some simple examples}
In this section we walk through most of the options of the {\tt correctSigns}
function.  We will work with the following six records as example.
<<keep.source=TRUE>>=
(dat <- data.frame(
    x = c( 3, 14, 15,  1, 17, 12.3),
    y = c(13, -4,  5,  2,  7, -2.1),
    z = c(10, 10,-10, NA, 10, 10 )))
@
We subject this data to the rule
\begin{equation}
z = x-y.
\end{equation}
With the {\tt editrules} package, this rule can be parsed to an {\tt editmatrix}.
<<keep.source=true>>=
require(editrules)
E <- editmatrix(c("z == x-y"))
@
Obviously, not all records in {\tt dat} obey this rule. This can be checked with 
a function from the {\tt editrules} package:
<<>>=
cbind(dat, violatedEdits(E,dat))
@
Records 1, 2, 3 and 6 violate the editrule, record 5 is valid and for record 4
validity cannot be established since it has no value for $z$.  If  {\tt
correctSigns} is called without any options, all variables $x$, $y$ and $z$ can
be sign-flipped:
<<>>=
sol <- correctSigns(E, dat)
cbind(sol$corrected, sol$status)
sol$corrections
@
So, the first three records have been correcte by flipping the sign of $z$, $y$
and $z$ respectively.  Since no weight parameter was given, the weight is just
the number of variables whose have been sign-flipped.  Record 4 is not treated,
since validity could not be established, record 5 was valid to begin with and
record 6 could not be repaired with sign flips. However, record 6 seems to have
a rounding error.  We can try to accomodate for that by allowing a tolerance
when checking equalities.
<<>>=
sol <- correctSigns(E, dat, eps=2)
cbind(sol$corrected, sol$status)
sol$corrections
@
Indeed, changing the sign of $y$ in the last record brings the record within
the allowed tolerance.  Suppose that we have so much faith in the value of $z$,
that we do not wish to change it's sign.  This can be done with the {\tt
fixate} option:
<<>>=
sol <- correctSigns(E, dat, eps=2, fixate="z")
cbind(sol$corrected, sol$status)
sol$corrections
@
Indeed, we now find solutions whitout changing $z$, but at the price of more
sign flips.  By the way, the same result could have been obtained by
<<results=hide>>=
correctSigns(E, dat, flip=c("x","y"))
@
The sign flips in record 1 and three have the same effect of a variable swap. Allowing
for swaps can be done as follows.
<<keep.source=true>>=
sol <- correctSigns(E, dat, swap=list(c("x","y")), 
    eps=2, fixate="z")
cbind(sol$corrected, sol$status)
sol$corrections
@
Notice that apart from swapping, the algorithm still tries to correct records
by flipping signs.  What happened here is that the algorithm first tries to
flip the sign of $x$, then of $y$, and then it tries to swap $x$ and $y$.  Each
is counted as a single action. If no solution is found, it starts trying
combinations. In this relatively simple example the result turned out well. In
cases with more elaborate systems of equalities and inequalities, the result of
the algorithm becomes harder to predict for users. It is therefore in general
advisable to 
\begin{itemize}
\item Use as much knowledge about the data as possible to decide which
variables to flip sign and which variable pairs to swap.  The problem treated
in section \ref{exScholtusCorrectSigns} is a good example of this.
\item Keep {\tt flip} and {\tt swap} disjunct. It is better to run the data a few times 
        times through {\tt correctSigns} with different settings.
\end{itemize}
Not allowing any sign flips can be done with the option {\tt flip=c()}.
<<>>=
sol <- correctSigns(E, dat, flip=c(), swap=list(c("x","y")))
cbind(sol$corrected, sol$status) 
sol$corrections
@
This yields less corrected records. However running the data through 
<<>>==
correctSigns(E, sol$corrected, eps=2)$status
@
will fix the remaining edit violations, and yields code which is a lot easyer
to interpret.

<<echo=false, results=hide>>=
# make x and y swappable, swap a counts as one flip
correctSigns(E, dat, flip="z", swap=list(c("x","y")))

# same, but now, swapping is preferred (has lower weight)
correctSigns(E, dat, flip="z", swap=list(c("x","y")), weight=c(2,1))

# same, but now becayse x any y carry lower weight. Also allow for rounding errors
correctSigns(E, dat, flip="z", swap=list(c("x","y")), eps=2, weight=c(x=1, y=1, z=3))

# demand that solution has y>0
E <- editmatrix(c("z==x-y", "y>0"))
correctSigns(E,dat)

# demand that solution has y>0, taking acount of roundings in equalities
correctSigns(E,dat,eps=2)
@

\subsection{Sign errors in a profit-loss account}
\label{exScholtusCorrectSigns}
Here, we will work through the example of chapter $3$ of \citet{scholtus:2008}.
This example considers 4 records, labeled case a, b, c, and d, which can be
defined in {\tt R} as
<<keep.source=TRUE>>=
dat <- data.frame(
   case = c("a","b","c","d"),
   x0r = c(2100,5100,3250,5726),
   x0c = c(1950,4650,3550,5449),
   x0  = c( 150, 450, 300, 276),
   x1r = c(   0,   0, 110,  17),
   x1c = c(  10, 130,  10,  26),
   x1  = c(  10, 130, 100,  10),
   x2r = c(  20,  20,  50,   0),
   x2c = c(   5,   0,  90,  46),
   x2  = c(  15,  20,  40,  46),
   x3r = c(  50,  15,  30,   0),
   x3c = c(  10,  25,  10,   0),
   x3  = c(  40,  10,  20,   0),
   x4  = c( 195, 610,-140, 221))
@
A record consists of 4 balance accounts wose results have to add up to a total.
Each $x_{i,r}$ denotes some kind of return, $x_{ic}$ some kind of cost and
$x_i$ the difference $x_{i,r}-x_{i,c}$. There are operating, financial,
provisions and exeptional incomes and expenditures. The differences $x_0$,
$x_1$, $x_2$ and $x_3$ have to add up to a given total $x_4$.  These linear
restrictions can be defined with the use of the {\tt editrules} package.
<<keep.source=TRUE>>=
require(editrules)
E <-editmatrix(c(
    "x0 == x0r - x0c",
    "x1 == x1r - x1c",
    "x2 == x2r - x2c",
    "x3 == x3r - x3c",
    "x4 == x0 + x1 + x2 + x3"))
E
@
Checking which records violate what edit rules can be done with the {\tt
violatedEdits} function of {\tt editrules}. 
<<>>=
violatedEdits(E,dat)
@
So record 1 (case a) for example, violates the restrictions $e_1$:
$x_1=x_{1,r}-x_{1,c}$ and $e_5$, $x_1+x_2+sx_3=x_4$.  We can try to solve the
inconsistencies by allowing the following flips and swaps:
<<keep.source=TRUE>>= 
swap <- list(
    c("x1r","x1c"), 
    c("x2r","x2c"), 
    c("x3r","x3c"))
flip <- c("x0","x1","x2","x3","x4")
@
%
Trying to correct the records by just flipping and swapping variables
indicated above corresponds to trying to solve the system of equations
\begin{equation}
\left\{\begin{array}{lcl}
x_0s_0 &=& x_{0,r}-x_{0,c}\\
x_1s_1 &=& (x_{1,r}-x_{1,c})t_1\\
x_2s_2 &=& (x_{2,r}-x_{2,c})t_2\\
x_3s_3 &=& (x_{3,r}-x_{3,c})t_3\\
x_4s_4 &=& x_0s_0 + x_1s_1 + x_2s_2 + x_3s_3\\
\multicolumn{3}{l}{(s_0,s_1,s_2,s_3,s_4,t_1,t_2,t_3)\in\{-1,1\}^{8}},
\end{array}\right.
\end{equation}
where every $s_i$ corresponds to a sign flip and $t_j$ corresponds
to a value swap, see also Eqn.\ (3.4) in \cite{scholtus:2008}.
Using the {\tt correctSigns} function, we get the following.
<<>>=
cor <- correctSigns(E, dat, flip=flip, swap=swap)
cor$status
@
As expected from the example in the reference, the last record could
not be corrected because the solution is masked by a rounding errors.
This can be solved by allowing a tolerance of two measurements units.
<<>>=
cor <- correctSigns(E, dat, flip=flip, swap=swap, eps=2)
cor$status
cor$corrected
@
The latter table corresponds exactly to Table $2$ of \cite{scholtus:2008}.

\section{Final remarks}
This paper demonstrates our implementation of three data correction methods,
initially devised by one of us (\cite{scholtus:2008, scholtus:2009}).  With the
{\tt deducorrect} R package, users can correct numerical data records which
violate linear equality restrictions for rounding errors, typographical errors
and sign errors and/or value transpositions. Since both the algorithms
correcting for typographical and sign errors can take rounding errors into
account, a typical data-cleaning sequence would be to start with correcting for
sign- and typographical errors, ignoring rounding errors and subsequently
treating the rounding errors. We note that data cleaning can be sped up
significantly if independent blocks of editrules are treated separately. Two
sets of editrules $A$ and $B$ are independent when variables occuring
in rules of $A$ do not occur in rules of $B$. The {\tt editrules} package
offers functionality to split editmatrices into blocks (with the {\tt findblocks}
function).



\bibliographystyle{chicago}
\bibliography{deducorrect}

\newpage
\appendix
\section{Some notes on the {\tt editrules} package}
The {\tt editrules} package \citep{jonge:2011} is a package for reading, parsing and
manipulating numerical and categorical editrules. It offers functionality to
conveniently construct edit matrices from verbose edit rules, stated as 
R statements. As an example consider the following set of edits on 
records with profit $p$, loss $l$, and turnover $t$.
\begin{equation}
\left\{\begin{array}{lcl}
t &\geq& 0\\
l &\geq& 0\\
t &=& p + l \\
p &<& 0.6t.  
\end{array}\right.
\end{equation}
The first two rules indicate that turnover and loss must be positive numbers,
the third that the profit-loss account must balance, and the last rule indicates
that profit cannot be more thatn 60\% of the turnover. Denoting a record as
a vector $(p,l,t)$,  these rules can be
denoted as matrix equations:
\begin{eqnarray}
\left[\begin{array}{ccc}
0 & 0 & 1\\
0 & 1 & 0\\
\end{array}\right]
\left[\begin{array}{c}p\\l\\t\end{array}\right] &\geq& 
\left[\begin{array}{c}1\\0\end{array}\right]\\
\left[\begin{array}{ccc}
1 & 1 & -1
\end{array}\right]
\left[\begin{array}{c}p\\l\\t\end{array}\right] &=& 0\\
\left[\begin{array}{ccc}
1 & 0 & -0.6
\end{array}\right] 
\left[\begin{array}{c}p\\l\\t\end{array}\right] &<& 0
\end{eqnarray}
In the {\tt editrules} package, these linear rules are all stored in a single object, called an
{\tt editmatrix}. It can be constructed as follows:
<<keep.source=true>>=
(E <- editmatrix(c(
    "t >= 1", 
    "l >= 0",
    "t == p + l",
    "p < 0.6*t")))
@
An {\tt editmatrix} object stores a stacked matrix representation of linear
edit resrictions. There are more storage modes in {\tt editrules} which we will
not detail here. Users can extract
(in)equalities through the {\tt getOps} function which returns a vector of
comparison operators for every row. For example:
<<keep.source=true>>=
E[getOps(E)==">=", ]
@
Alternatively, an the comparison operators of an editmatrix may be normalized:
<<>>=
editmatrix(editrules(E),normalize=TRUE)
@
The {\tt editrules} package offers functionality to check data against any set
of editrules. The function {\tt violatedEdits}, for example returns a boolean
matrix indicating which record violates what editrules. {\tt editrules} also
offers editrule manipulation functionality, for example to split editmatrices
into independent blocks. For further functionality of the {\tt editrules}
package, refer to the package documentation.




\end{document}
