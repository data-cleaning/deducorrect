%\VignetteIndexEntry{deducorrect}
\documentclass[10pt, fleqn, a4paper]{article}
\usepackage[english]{babel}
\usepackage{amsmath, amssymb}
\usepackage{natbib}
%\usepackage{algorithmic}
\usepackage{algpseudocode}
\usepackage{algorithm}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{threeparttable}

% stimulate latex to put multiple floats on a page.
\setcounter{topnumber}{2}
\setcounter{bottomnumber}{2}
\setcounter{totalnumber}{3}
\setcounter{dbltopnumber}{2}
\renewcommand{\topfraction}{.9}
\renewcommand{\textfraction}{.1}
\renewcommand{\bottomfraction}{.75}
\renewcommand{\floatpagefraction}{.9}
\renewcommand{\dblfloatpagefraction}{.9}
\renewcommand{\dbltopfraction}{.9}


\title{The {\tt deducorrect} vignette}
\author{Mark van der Loo, Edwin de Jonge and Sander Scholtus}
\begin{document}
\maketitle
\begin{abstract}
This vignette is unfinished. Version 1.0 of the package will contain a full vignette.
\end{abstract}

<<echo=FALSE,results=hide, keep.source=FALSE>>=
library(deducorrect)
@
\maketitle
\tableofcontents
\listofalgorithms
\newpage
\section{Introduction}
Raw data  is often plagued with internal inconsistencies which interfere with
statistical analysis. Data stemming from establishment surveys are particularly
prone to inconsistencies since they consist of many numerical variables,
interrelated by numerous mathematical relationships. Before statistical
analysis can take place, these relationships have to be checked on a
record-by-record basis, and violations resolved as much as possible.  While
establishing that a records violates certain relationships is simple, deciding
which fields in a record contains the actual errors can be a difficult task. In
the past, much attention has been paid to this decision problem, often using
Fellegi and Holt's principle \cite{fellegi:1976} as a starting point. This
principle states that for non-systematic errors, and with no information on the
cause of the errors, one should try to make a record consistent by changing as
few variables as possible.

This principle precludes using the data available in the (possibly erroneous)
fields to detect and correct the error. In certain cases, naivelily applying
Fellegi and Holt's principle will yield consistent records with nevertheless
faulty data. As an example, consider a survey record with three variables $x$,
$y$ and $z$, which have to obey the relationship $x=y-z$. Such relationships
frequently occur in profit-loss accounts. If a record happens to have values
such that $x=z-y$, then Fellegi and Holt's principle suggests that either the
numerical value of $x$, $y$ or $z$ should be adapted in such a way that the
relationship holds, while the values in the record suggest that the values in
fields $y$ and $z$ have been interchanged. Swapping the values of $z$ and 
$y$ therefore seems a reasonable solution although it formally means changing
two values.

\paragraph{Note.} 


We will use these terms 
as well.

\subsection{Deductive correction}
We use the term deductive correction to indicate methods wich use information
available in inconsistent records to deduce and solve the probable cause of
error. Recently, a number of algorithms for deductive correction have
been proposed by \cite{scholtus:2008, scholtus:2009}. These algorithms
can solve problems not uncommon in numerical survey data, namely
%
\begin{itemize}
\item Rounding errors.
\item Simple typing errors.
\item Sign swaps and/or value interchanges.
\end{itemize}
%
The algorithms focus on solving problems in records with linear relationships,
which can be written in any (combination of) the forms
%
\begin{eqnarray}
\label{edits1}
Ax &=& b\\
\label{edits2}
Ax &<& b \\
\label{edits3}
Ax &\leq& b \\
\label{edits4}
Ax &>& b \\
\label{edits5}
Ax &\geq& b 
\label{edits6}
\end{eqnarray}
%
Here, every $A$ is a matrix, $x$ a numerical data record and $b$ a constant
vector. Every row of the combined matrix $[A,b]$ represents one linear restriction. In
data-editing literature the restrictions imposed on records are often called
edit rules or edits, in short. If an edit describes a relationship between
a number of variables $\{x_j\}$, we say that the edit {\em contain} the variables
$\{x_j\}$. Conversely, when $x_j$ is part of a relationship defined by an edit
we say that $x_j$ {\em occurs} in the edit. 

In this paper, we describe the {\tt deducorrect} package for R
\citep{R-core:2011}, which implements (slight) generalisations of the
algorithms proposed by \cite{scholtus:2008, scholtus:2009}. The purpose of this
paper is to provide details on the algorithms and to familiarize users with the
syntax of the package. The correction algorithms in the package report the
results in a uniform matter. Section \ref{deducorrectObjectSection} provides details
on the {\tt deducorrect} output object. Sections \ref{roundingErrors}, \ref{typingErrors} and
\ref{signErrors}, provide details on the classes of problems that may be
treated with the package, an exposition of the algorithms used and coded
examples with analysis of the results. It is also shown how the examples
from \cite{scholtus:2008} and \cite{scholtus:2009} can be treated with
this software. The package requires that linear relationships are 
defined with the {\tt editrules} package \citep{jonge:2011}. All
R-code examples in this paper can be executed from the R commandline
after loading the {\tt deducorrect} and {\tt editrules} package.


\subsection{The {\tt deducorrect} object and {\tt status} values}
\label{deducorrectObjectSection}
When transforming raw data to a form suitable for statistical processing, it is important to keep
track of the applied transformations so they can be taken into account when interpreting the results
of the statistical analyses. To facilitate logging, every {\tt correct-} function of the package 
does not only return the corrected data, but also information on the applied corrections,
a timestamp and the user running R. See Table \ref{deducorrectObject} for an overview.
%
\begin{table}
\begin{threeparttable}
\caption{Contents of the {\tt deducorrect} object. All slots can be accessed or reassigned through the {\tt \$} operator.}
\label{deducorrectObject}
\begin{tabular}{lp{0.7\textwidth}}
\hline
{\tt corrected}   & The input data with records corrected where possible.\\
{\tt corrections} & A {\tt data.frame} describing the corrections. Every record contains a row number, labeling the
row in the input data, a variable name of the input data, the old value and the new value.\\
{\tt status} & A {\tt data.frame} with at least one column giving treatment information of every record in the input data.
    Depending on the {\tt correct} function, some extra columns may be added. \\
{\tt timestamp}   & The date and time when the {\tt deducorrect} object was created.\\
{\tt generatedby} & The name of the function that called {\tt newdeducorrect} to create the object.\\
{\tt user}        & The name of the user running R, deduced from the environment variables of the system using R.\\
\hline
\end{tabular}
\end{threeparttable}
\end{table}
%

When printed, not al slots are written to the screen. In stead, a summary of it's contents is given.
In this example, we define one record of data, a linear restriction, in the form of an {\tt editmatrix},
and apply the {\tt correctSigns} correction method\footnote{sometimes extra
brackets are included to force R to print the result}.
<<>>=
(d <- data.frame(x=1,y=0,z=1))
require(editrules)
E <- editmatrix("x==y-z")
sol <- correctSigns(E,d)
sol
@
%
\begin{table}
\begin{threeparttable}
\caption{Status values in the {\tt deducorrect} object. The precise meaning depends on the 
applied {\tt correct-} function. See sections  \ref{roundingErrors}, \ref{typingErrors} and \ref{signErrors}
for the appropriate descriptions.}
\label{statusvalues}
\begin{tabular}{lp{0.7\textwidth}}
\hline
Status & description\\
\hline
{\tt NA}        & Validity of the record could not be established.\\
{\tt valid}     & The record obeys all restrictions.\\
{\tt corrected} & The record contained inconsistencies but now obeys all restrictions.\\
{\tt partially} & The record contained inconsistencies which could partially be solved.\\
{\tt invalid}   & The record containes inconsistencies which could not be solved.\\
\hline
\end{tabular}
\end{threeparttable}
\end{table}
%
The individual components of {\tt sol} can be retrieved with the dollar-operator. The slot
{\tt corrected} is the same as the input data, but with corrected records, where possible:
<<>>=
sol$corrected
@
The applied corrections are stored in the {\tt corrections} slot.
<<>>=
sol$corrections
@
Every row in {\tt corrections} tells wich variable in which row of the input
data was changed, and what the old and new values are. The {\tt status} slot
gives details on the status of the record.
<<>>=
sol$status
@
The first column is an indicator which can take five different values, indicating
whether validity could be established, and/or if the record could be (partially)
corrected by the method which created the deducorrect object. See Table \ref{statusvalues}
for details. The rest of the columns depend on the function which created the
object and can provide more details on the chosen solutions. These are 
described in the following sections.






\section{\tt correctRoundings}
\label{roundingErrors}
\subsection{Area of application}
This function can be used to correct records which violate linear equality restrictions because of
rounding errors in one or more variables.
\subsection{How it works}
\subsection{Examples}

\section{\tt correctTypos}
\label{typingErrors}
\subsection{Area of application}
This function can be used to correct typographical errors in a numerical record
violating linear equality constraints. \marginpar{TODO: describe behaviour
under inequalities for version 1.0} The algorithm can only be applied to records
containing integer data.

\subsection{How it works}
In short, the algorithm first computes a list of suggestions which correct one
or more violated edits (Algorithm \ref{generateCandidates}). The corrections
not corresponding to a typographical error are removed, after which  the set of
suggestions that maximize the number of satisfied editrules is determined
(Algorithm \ref{maximizeResolvedEdits}). 

Suggestions are generated for the set of variables which {\em only} occur
in violated edits since altering these variables will have no effect on
already satisfied edits. For every variable $x_j$, define the matrix $A^{(j)}$ who's
rows represent edits containing $x_j$. Suggestions $\tilde{x}^{(i)}_j$ for
every row $i$ of $A^{(j)}$ can be generated by solving for $x_j$:
%
\begin{equation}
\tilde{x}_j^{(i)} = \frac{1}{A_{ij}^{(j)}} \left(b_i - \sum_{j'\not=j}A_{ij'}^{(j)}x_j\right).
\end{equation}
%
We keep only the unique suggestions, and reject solutions which are more than a
certain Damerau-Levenshtein distance removed from the original value. The {\em
Damerau-Levenshtein} distance $d_{\rm DL}$ between two strings $s$ and $t$ is
the minimum number of character insertions, deletions, substitutions and
transpositions necessary to change $s$ into $t$ or {\em vice versa}
\citep{damerau:1964,levenshtein:1966}. 
The remaining set of suggestions $\{x^{(i)}_j\}$ will in general contain
multiple suggestions for each violated edit $i$ and multiple suggestions for
each variable $x_j$. Using a tree search algorithm, a subset of $\{x^{(i)}_j\}$
is selected which maximizes the number of resolved edits. The tree
search is sped up considerably by pruning branches which resolve the same
edit multiple times or use multiple suggestions for the same variable.

This algorithm generalizes the algorithms of \cite{scholtus:2009} in the following
two ways: first, the imposed linear restrictions are generalised from $Ax=0$ to
$Ax=b$. Secondly, the original algorithm allowed for a single {\em digit} insertion,
deletion, transposition or substitution. The more general Damerau-Levenshtein distance
used here treats the digits as characters, allowing for sign changing (inserting a{\tt -} sign
is one insertion). Also, by applying a standard Damerau-Levenshtein algorithm it is easy
to allow for corrections spanning larger values $d_{\rm DL}$. That is, one could
allow for multiple typos in a single field.
%
%
\begin{algorithm}[t]
\caption{Generate solution candidates}
\label{generateCandidates}
\begin{algorithmic}[1]
\Require Record $x$, a set of linear equality restrictions and a list of variables to {\tt fixate}. A maximum
Damerau-Levenshtein distance {\tt maxdist}.
\State $L\leftarrow\varnothing$
\State Determine $J_0=\{j: x_j \textrm{ occurs {\em only} in violated edits and not in {\tt fixate}}\}$
\For { $j\in J_0$}
\State Determine the matrix $A^{(j)}$ of violated edits containing $x_j$ and associated constant vector $b^{(j)}$
\For { every row $i$ of $A^{(j)}$}
\State $\tilde{x}_j^{(i)} \leftarrow \left(b_i^{(j)}-\sum_{j'\not=j}A_{ij'}^{(j)}x_{j'}\right)/A_{ij}^{(j)} $
\State $L\leftarrow L\cup\tilde{x}_j^{(i)}$
\EndFor
\EndFor
\State Remove $\tilde{x}^{(i)}_j$ from $L$ for which $d_{\rm DL}(\tilde{x}^{(i)}_j,x_j)>{\tt maxdist}$ 
\Ensure List $L$ of $m$ unique solution suggestions for record $x$.
\end{algorithmic}
\end{algorithm}
%
\begin{algorithm}[t]
\caption{Maximize number of resolved edits}
\label{maximizeResolvedEdits}
\begin{algorithmic}[1]
\Require Record $x$, a list of linear equality restrictions and a list of solution suggestions
$L = \{L_\ell=\tilde{x}^{(i_\ell)}_{j_\ell}:\ell=1,2,\ldots, m\}$
\State $k\leftarrow 0$ 
\State $s\leftarrow {\sf NULL}$
\Procedure{tree}{$x,L$}
\If{$L\not=\varnothing$}
\State {\sc tree}$(x,L\backslash L_1)$\Comment{Left branche: don't use suggestion}
\State $x_{j_1}\leftarrow L_1$ \Comment{Right branche: use suggestion}
\State $L\leftarrow L\backslash \{x^{(i_\ell)}_{j_\ell}\in L: j_\ell=j_1 \textrm{ \bf  or } x^{(i_\ell)}_{j_\ell}\textrm{ resolves the same edit as } L_1\}$
\State {\sc tree}$(x,L)$
\Else
\If{Number of edits $n$ resolved by $x$ larger then $k$}
\State $k \leftarrow n$
\State $s \leftarrow x$
\EndIf
\EndIf
\EndProcedure
\Ensure { (partial) solution $s$, resolving maximum number of edits. }
\end{algorithmic}
\end{algorithm}

\subsection{Some simple examples}


\section{\tt correctSigns}
\label{signErrors}
\subsection{Area of application}
This function can be used to solve sign errors and value swaps which cause
linear equalities (Eq. \ref{edits1}) to fail. Possible presence of linear
inequalities [Eq. \eqref{edits2}-\eqref{edits6}] are taken into account
when resolving errors, but they are not part of the error detection process.
The {\tt status} values for a record treated by {\tt correctSigns} therefore
has the following meanings.

\begin{description}
\item[{\tt valid}] No linear equalities were violated. Linear inequalities might be violated however.
\item[{\tt corrected}] The record violate linear equalities, and possible linear inequalities. All (in)equalities
    are obeyed by the treated record.
\item[{\tt partially}] Does not occur.
\item[{\tt invalid}] The record violates linear inequalities which could not be repaired by {\tt correctSigns}.
\item[{\tt NA}]  Validity of record could not be established.
\end{description}


\subsection{How it works}
%
%
\begin{algorithm}
\caption{Record correction for {\tt correctSigns}}
\label{correctSigns}
\begin{algorithmic}[1]
\Require A numeric record $x$, a tolerance $\varepsilon$. A set of equality and inequality constraints of the form
\begin{eqnarray*}
Ax - b &=& 0\\
Bx - c &\geq& 0,
\end{eqnarray*}
A list {\tt flip} of variables whos signs may be fliped, a list {\tt swap} of
variable pairs whos values may be interchanged, an integer {\tt maxActions}, an
integer {\tt maxCombinations} and a weight vector.

\State Create a list {\tt actions}, of length $n$ containing those elements of {\tt flip} and {\tt swap} that
    affect variables that occur in violated rows of $A$.
\State Create an empty list $S$.
\State $k\leftarrow 0$
\While {$S=\varnothing$ {\bf and} $k<\min({\tt maxActions},n)$}
  \If {{\bf not} ${n\choose k}>{\tt maxCombinations}$}
   \State $k\leftarrow k+1$ 
   \State Generate all ${n\choose k}$ combinations of $k$ actions.
   \State Loop over those combinations, applying them to $x$. Add solutions obeying $|Ax-b|<\varepsilon$ and $Ax-c\geq0$ to $S$.
  \EndIf
\EndWhile
\If {{\bf not} $S=\varnothing$ }
\State Compute solution weights and choose solution with minimum weight. Choose the first solution in the case of degeneracy.
\EndIf
\end{algorithmic}
\end{algorithm}
The function {\tt correctSigns} tries to change the sign of (combinations of)
variables and/or swap the order of variables to repair inconsistent records.
Sign flips and value swaps are closely related since
\begin{equation}
-(x - y) = y - x,
\end{equation}
These simple linear relations frequently occur in profit-loss accounts for
example.  Basically, {\tt correctSigns} first tries to correct a record by
changing one sign. If that doesn't yield any solution, it tries changing two,
and so on. If the user allows value swaps as well, it starts by trying to
correct the record with a single sign flip or variable swap. If no solution is
found, a combination is tried, and so on. The algorithm only treats the
variables which have nonzero coefficients in one of the violated rows of Eq.\
\eqref{edits1}.  Since the number of combinations grows exponentially with the
number of variables to treat, the user is given some control over the volume of
the search space to cover in a number of ways. First of all, the variables
which are allowed to flip signs or variable pairs which may be interchanged
simultaneously can be determined by the user. Knowledge of the origin of the
data will usually give a good idea on which variables are prone to sign errors.
For example, in surveys on profit-loss accounts, respondents sometimes
erroneously submit the cost as a negative number. Secondly, the user may limit
the maximum number of simultaneous sign flips and or value swaps that may be
tested. This is controled by the {\tt maxActions} parameter in Algorithm
\ref{correctSigns}.  The third option limiting the search space is to break
when the number of combinations, given a number of actions to try becomes too
large. This is controlled by the {\tt maxCombinations} parameter in Algorithm
\ref{correctSigns}.


To account for sign errors and variable swap errors which are masked by 
rounding errors, the user can provide a nonegative tolerance $\varepsilon$, so the
set of equality constraints are checked as
\begin{equation}
|Ax -b| < \varepsilon,
\end{equation}
where $|\cdot|$ indicates the elementwise absolute value. The default value of
$\varepsilon$ is the square root of machine accuracy which amounts to
approximately $10^{-8}$ on a 32-bit architecture. 

The purpose of this algorithm is to find and apply the minimal number of
actions (sign flips and/or variable swaps) necessary to repair the record. It
is not guaranteed that a solution exists, nor that the solution is unique. If
multiple solutions are found, the solution which minimizes a weight is chosen.
The user has the option to assign weights to every variable, or to every
action.  The total weight of a solution is the sum over the weights of the
altered variables or the sum over the weight of the actions performed. Actions
with heigher weight are therefore less likely to be performed and variables
with higher weight are less likely to be altered.

This algorithm is a generalization of the original algorithms in \cite{scholtus:2008}
in two ways. First, the original algorithm was designed with a specific type of
profit-loss account in mind, while the algorithm of {\tt deducorrect} can handle any
set of linear equalities. Second, the original algorithm was not designed to 
take account of inequality restrictions, which is a feature of the algorithm
in this work. In Section \ref{exScholtusCorrectSigns} it is shown how the 
results of the original example can be reproduced.



%
%
\subsection{Some simple examples}
In this section we walk through most of the options of the {\tt correctSigns} function.
We will work with the following six records as example.
<<keep.source=TRUE>>=
(dat <- data.frame(
    x = c( 3, 14, 15,  1, 17, 12.3),
    y = c(13, -4,  5,  2,  7, -2.1),
    z = c(10, 10,-10, NA, 10, 10 )))
@
We subject this data to the rule
\begin{equation}
z = x-y.
\end{equation}
With the {\tt editrules} package, this rule can be parsed to an {\tt editmatrix}.
<<keep.source=true>>=
require(editrules)
E <- editmatrix(c("z == x-y"))
@
Obviously, not all records in {\tt dat} obey this rule. This can be checked with 
a function from the {\tt editrules} package:
<<>>=
cbind(dat, violatedEdits(E,dat))
@
Records 1, 2, 3 and 6 violate the editrule, record 5 is valid and for record 4
validity cannot be established since it has no value for $z$. 
If  {\tt correctSigns} is called without any options, all variables $x$, $y$ and $z$
can be sign-flipped:
<<>>=
sol <- correctSigns(E, dat)
cbind(sol$corrected, sol$status)
sol$corrections
@
So, the first three records have been correcte by flipping the sign of $z$, $y$ and $z$ respectively.
Since no weight parameter was given, the weight is just the number of variables whose have been sign-flipped.
Record 4 is not treated, since validity could not be established, record 5 was valid to begin with and
record 6 could not be repaired with sign flips. However, record 6 seems to have a rounding error.
We can try to accomodate for that by allowing a tolerance when checking equalities.
<<>>=
sol <- correctSigns(E, dat, eps=2)
cbind(sol$corrected, sol$status)
sol$corrections
@
Indeed, changing the sign of $y$ in the last record brings the record within the allowed tolerance.
Suppose that we have so much faith in the value of $z$, that we do not wish to change it's sign.
This can be done with the {\tt fixate} option:
<<>>=
sol <- correctSigns(E, dat, eps=2, fixate="z")
cbind(sol$corrected, sol$status)
sol$corrections
@
Indeed, we now find solutions whitout changing $z$, but at the price of more sign flips.
By the way, the same result could have been obtained by
<<results=hide>>=
correctSigns(E, dat, flip=c("x","y"))
@
The sign flips in record 1 and three have the same effect of a variable swap. Allowing
for swaps can be done as follows.
<<keep.source=true>>=
sol <- correctSigns(E, dat, swap=list(c("x","y")), 
    eps=2, fixate="z")
cbind(sol$corrected, sol$status)
sol$corrections
@
Notice that apart from swapping, the algorithm still tries to correct records by flipping signs.
What happens is that the algorithm first tries to flip the sign of $x$, then of $y$, and then it tries to swap $x$ and $y$.
Each is counted as a single action. If no solution is found, it starts trying combinations. In this relatively simple 
example the result turned out well. In cases with more elaborate systems of equalities and inequalities, the 
result of the algorithm becomes harder to predict for users. It is therefore in general advisable to 
\begin{itemize}
\item Use as much knowledge about the data as possible to decide which variables to flip sign and which variable pairs to swap.
    The problem treated in section \ref{exScholtusCorrectSigns} is a good example of this.
\item Keep {\tt flip} and {\tt swap} disjunct. It is better to run the data a few times 
        times through {\tt correctSigns} with different settings.
\end{itemize}
Not allowing any sign flips can be done with the option {\tt flip=c()}.
<<>>=
sol <- correctSigns(E, dat, flip=c(), swap=list(c("x","y")))
cbind(sol$corrected, sol$status)
sol$corrections
@
This yields less corrected records. However running the data through 
<<>>==
correctSigns(E, sol$corrected, eps=2)$status
@
will fix the remaining edit violations, and yields code which is a lot easyer to interpret.

<<echo=false, results=hide>>=
# make x and y swappable, swap a counts as one flip
correctSigns(E, dat, flip="z", swap=list(c("x","y")))

# same, but now, swapping is preferred (has lower weight)
correctSigns(E, dat, flip="z", swap=list(c("x","y")), weight=c(2,1))

# same, but now becayse x any y carry lower weight. Also allow for rounding errors
correctSigns(E, dat, flip="z", swap=list(c("x","y")), eps=2, weight=c(x=1, y=1, z=3))

# demand that solution has y>0
E <- editmatrix(c("z==x-y", "y>0"))
correctSigns(E,dat)

# demand that solution has y>0, taking acount of roundings in equalities
correctSigns(E,dat,eps=2)
@

\subsection{Sign errors in a profit-loss account}
\label{exScholtusCorrectSigns}
Here, we will work through the example of chapter $3$ of \citet{scholtus:2008}.
This example considers 4 records, labeled case a, b, c, and d, which can 
be defined in {\tt R} as
<<keep.source=TRUE>>=
dat <- data.frame(
   case = c("a","b","c","d"),
   x0r = c(2100,5100,3250,5726),
   x0c = c(1950,4650,3550,5449),
   x0  = c( 150, 450, 300, 276),
   x1r = c(   0,   0, 110,  17),
   x1c = c(  10, 130,  10,  26),
   x1  = c(  10, 130, 100,  10),
   x2r = c(  20,  20,  50,   0),
   x2c = c(   5,   0,  90,  46),
   x2  = c(  15,  20,  40,  46),
   x3r = c(  50,  15,  30,   0),
   x3c = c(  10,  25,  10,   0),
   x3  = c(  40,  10,  20,   0),
   x4  = c( 195, 610,-140, 221))
@
A record consists of 4 balance accounts wose results have to add up to a total.
Each $x_{i,r}$ denotes some kind of return, $x_{ic}$ some kind of cost and
$x_i$ the difference $x_{i,r}-x_{i,c}$. There are operating, financial,
provisions and exeptional incomes and expenditures. The differences $x_0$, $x_1$,
$x_2$ and $x_3$ have to add up to a given total $x_4$.  These linear
restrictions can be defined with the use of the {\tt editrules} package.
<<keep.source=TRUE>>=
require(editrules)
E <-editmatrix(c(
    "x0 == x0r - x0c",
    "x1 == x1r - x1c",
    "x2 == x2r - x2c",
    "x3 == x3r - x3c",
    "x4 == x0 + x1 + x2 + x3"))
E
@
Checking which records violate what edit rules can be done with the {\tt violatedEdits}
function of {\tt editrules}. 
<<>>=
violatedEdits(E,dat)
@
So record 1 (case a) for example, violates the restrictions $e_1$: $x_1=x_{1,r}-x_{1,c}$
and $e_5$, $x_1+x_2+sx_3=x_4$. 
We can try to solve the inconsistencies by allowing the following flips
and swaps:
<<keep.source=TRUE>>= 
swap <- list(
    c("x1r","x1c"), 
    c("x2r","x2c"), 
    c("x3r","x3c"))
flip <- c("x0","x1","x2","x3","x4")
@
%
Trying to correct the records by just flipping and swapping variables
indicated above corresponds to trying to solve the system of equations
\begin{equation}
\left\{\begin{array}{lcl}
x_0s_0 &=& x_{0,r}-x_{0,c}\\
x_1s_1 &=& (x_{1,r}-x_{1,c})t_1\\
x_2s_2 &=& (x_{2,r}-x_{2,c})t_2\\
x_3s_3 &=& (x_{3,r}-x_{3,c})t_3\\
x_4s_4 &=& x_0s_0 + x_1s_1 + x_2s_2 + x_3s_3\\
\multicolumn{3}{l}{(s_0,s_1,s_2,s_3,s_4,t_1,t_2,t_3)\in\{-1,1\}^{8}},
\end{array}\right.
\end{equation}
where every $s_i$ corresponds to a sign flip and $t_j$ corresponds
to a value swap, see also Eqn.\ (3.4) in \cite{scholtus:2008}.
Using the {\tt correctSigns} function, we get the following.
<<>>=
cor <- correctSigns(E, dat, flip=flip, swap=swap)
cor$status
@
As expected from the example in the reference, the last record could
not be corrected because the solution is masked by a rounding errors.
This can be solved by allowing a tolerance of two measurements units.
<<>>=
cor <- correctSigns(E, dat, flip=flip, swap=swap, eps=2)
cor$status
cor$corrected
@
The latter table corresponds exactly to Table $2$ of \cite{scholtus:2008}.


\bibliographystyle{chicago}
\bibliography{deducorrect}

\newpage
\appendix
\section{Some notes on the {\tt editrules} package}

The {\tt editmatrix} function translates verbose editrules to the matrix equivalent.
The result should be read as follows: a record is valid when it obeys
$-1\cdot x + 1\cdot y + 1\cdot z = 0$.

\end{document}
